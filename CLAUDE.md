# Long-Running Agent Harness - 开发 SOP

> 本文档是所有 AI Agent 的行为规范。每次会话必须先读取本文档。

## 核心架构：双阶段 Harness

### 为什么需要双阶段设计

1. **Initializer（首轮）**：负责环境搭建、任务拆分、基础设施创建
   - 创建 `init.sh` 确保环境可复现
   - 生成初始 `Task.json` 任务列表
   - 建立 `progress.txt` 日志机制
   - 完成首次 git commit

2. **Coding Agent（后续每轮）**：负责增量推进
   - 读取状态文件恢复上下文
   - 每次只领取一个任务
   - 完成后更新状态并提交

### 为什么这样设计有效
- Agent 会话之间没有记忆，必须通过持久化文件传递状态
- 分离初始化和增量工作，避免每次都重复搭建环境
- 结构化任务列表防止遗漏和重复

---

## 常见失败模式与对策

| 失败模式 | 根因 | 对策 |
|---------|------|------|
| 过早宣布完成 | 没有客观验证标准 | 必须运行 `scripts/verify.sh` 通过后才能标记完成 |
| 功能实现一半 | 一次尝试太多 | 每次只领取一个任务，明确边界 |
| 进度丢失 | 没有状态交接 | 强制更新 `progress.txt` 和 git commit |
| 环境损坏 | 脏状态累积 | 每次会话开始运行 `init.sh` 恢复干净环境 |
| 不会启动项目 | 缺少启动脚本 | `init.sh` 必须能一键启动 |
| 缺少端到端测试 | 只跑单测 | 必须有 `scripts/verify.sh` 做端到端验证 |
| 任务状态错乱 | 大幅重写 Task.json | 只允许最小改动（改单个任务的 status/notes） |

---

## 会话开始 Checklist（必须执行）

```
我将先获取项目现状：读取 CLAUDE.md、progress.txt、Task.json，
查看 git log，运行初始化脚本并做一次最小验证测试，然后再领取一个任务。
```

### 具体步骤：

- [ ] 1. 读取 `CLAUDE.md`（本文档）
- [ ] 2. 读取 `progress.txt` 了解历史进度
- [ ] 3. 读取 `Task.json` 了解任务状态
- [ ] 4. 运行 `git log --oneline -10` 查看最近提交
- [ ] 5. 运行 `./init.sh` 初始化/恢复环境
- [ ] 6. 运行 `./scripts/verify.sh` 做最小验证测试
- [ ] 7. 从 Task.json 领取一个任务（状态改为 `in_progress`）

---

## 会话结束 Checklist（必须执行）

```
我已完成本轮任务推进：更新了 Task.json 与 progress.txt，
运行了验证，做了 git commit，并记录了下一轮建议领取的任务
（若有阻塞则已请求人工介入）。
```

### 具体步骤：

- [ ] 1. 运行 `./scripts/verify.sh` 验证改动
- [ ] 2. 更新 `Task.json` 中任务状态（completed/failed/blocked）
- [ ] 3. 追加记录到 `progress.txt`
- [ ] 4. 执行 `git add` 和 `git commit`
- [ ] 5. 在 `progress.txt` 记录下一轮建议领取的任务

---

## 6 步开发流程（每轮必须遵循）

### Step 1: 初始化/恢复环境
```bash
./init.sh
```
- 检查依赖是否齐全
- 确保环境可运行
- 启动必要服务

### Step 2: 领取任务
- 读取 `Task.json`
- 选择第一个 `status: "pending"` 且无阻塞依赖的任务
- 将其 `status` 改为 `"in_progress"`
- 更新 `last_update` 时间戳

### Step 3: 开发实现
- 只围绕当前任务做改动
- 保持改动聚焦、可回滚
- 不要同时修改多个不相关的功能
- **充分利用可用工具**（见下方"开发时可用的工具"）

### Step 4: 测试与验证
```bash
./scripts/verify.sh
```
- 必须运行端到端验证
- 未通过验证不得标记任务为完成
- 记录验证输出作为证据

### Step 5: 更新状态文件
- **成功**：`status` 改为 `"completed"`，写入验证证据
- **失败**：`status` 改为 `"failed"` 或 `"blocked"`，记录原因

### Step 6: Git 提交
```bash
git add -A
git commit -m "feat(task-N): 描述性消息"
```
- 每轮必须产生清晰 commit
- 禁止提交未验证的代码到主分支

---

## 文件修改约束

### Task.json 修改规则
- **禁止**：重写整个文件
- **禁止**：删除任务
- **禁止**：修改已完成任务的内容
- **允许**：修改单个任务的 `status`、`last_update`、`notes` 字段

### progress.txt 修改规则
- **禁止**：删除历史记录
- **禁止**：修改历史记录
- **允许**：在文件末尾追加新记录

---

## 人工介入规则

### 触发条件（任一满足必须求助）

1. **依赖缺失**：关键依赖无法安装或版本不确定
2. **连续失败**：同一任务尝试 3 次仍无法通过验证
3. **凭证需求**：需要 API Key、账户、密码等无权获取的资源
4. **无法定位**：测试失败但无法确定根因

### 求助包格式（Human Help Packet）

```
========== 人工介入请求 ==========
时间: [ISO 时间戳]
任务 ID: [task-N]
任务描述: [简述]

我做了什么:
- [步骤1]
- [步骤2]

我尝试过的修复:
- [尝试1]: [结果]
- [尝试2]: [结果]

错误日志:
```
[粘贴关键日志]
```

需要人做的决策:
- 选项 A: [描述]
- 选项 B: [描述]
- 选项 C: [其他建议]

最小复现命令:
```bash
[命令]
```
=====================================
```

---

## 安全刹车机制

### 自动停止条件
- 检测到 `STOP` 文件存在
- 检测到任务状态为 `blocked` 且需要人工介入
- 连续 3 个任务失败
- `init.sh` 执行失败

### 手动停止方法
```bash
touch STOP  # 创建 STOP 文件，下一轮循环会自动退出
```

---

## 任务状态定义

| 状态 | 含义 | 下一步 |
|------|------|--------|
| `pending` | 未开始 | 可被领取 |
| `in_progress` | 进行中 | 当前 Agent 正在处理 |
| `completed` | 已完成 | 验证通过，已提交 |
| `failed` | 失败 | 需要分析原因后重试 |
| `blocked` | 阻塞 | 需要人工介入 |

---

## 任务领取策略

1. 优先选择 `status: "pending"` 的任务
2. 按 `id` 顺序选择（小号优先）
3. 检查 `depends_on` 字段，确保依赖任务已完成
4. 如果所有任务都完成或阻塞，停止循环并报告

---

## 验证证据要求

每个任务完成时，必须在 `notes` 中记录：
- 验证命令及输出摘要
- 关键文件的修改列表
- 任何需要后续关注的事项

---

## 开发时可用的工具

在执行任务时，应充分利用以下工具来提高效率和质量：

### Skills（通过 /skill 调用）

| Skill | 用途 | 何时使用 |
|-------|------|----------|
| `/commit` | 智能提交 | 任务完成后提交代码 |
| `/review-pr` | PR 审查 | 代码审查 |
| `/plan` | 实现规划 | 复杂任务开始前 |
| `/tdd` | 测试驱动开发 | 编写新功能时 |
| `/security-review` | 安全审查 | 涉及认证、用户输入时 |

### MCP 工具

根据项目配置的 MCP 服务器，可使用：
- **浏览器自动化**：用于 E2E 测试、网页交互
- **数据库操作**：直接查询/修改数据库
- **API 调用**：与外部服务交互
- **文件系统扩展**：高级文件操作

### 子代理（Task 工具）

| Agent | 用途 |
|-------|------|
| `planner` | 复杂功能的实现规划 |
| `code-reviewer` | 代码审查 |
| `tdd-guide` | 测试驱动开发指导 |
| `security-reviewer` | 安全漏洞检查 |
| `build-error-resolver` | 构建错误修复 |

### 使用原则

1. **主动使用**：不要等用户要求，根据任务性质主动选择合适的工具
2. **组合使用**：复杂任务可以组合多个工具
3. **记录使用**：在 progress.txt 中记录使用了哪些工具及效果

### 示例：实现一个 API 端点

```
1. /plan - 先规划实现方案
2. /tdd - 用 TDD 方式编写
3. 使用 MCP 浏览器工具做 E2E 测试
4. /security-review - 检查安全问题
5. /commit - 提交代码
```

---

## 循环执行命令

当用户说"继续"、"下一个"、"执行"时，自动进入任务循环：

1. 执行会话开始 Checklist
2. 领取并完成一个任务（使用所有可用工具）
3. 执行会话结束 Checklist
4. 询问用户是否继续下一个任务

当用户说"自动执行 N 个任务"时：
- 连续执行 N 个任务
- 每个任务之间不暂停
- 遇到 blocked 或失败时停止并报告

